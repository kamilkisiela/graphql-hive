on:
  workflow_call:
    secrets:
      stripeTestPublicKey:
        required: true
      stripeTestSecretKey:
        required: true
    inputs:
      registry:
        default: ghcr.io
        type: string
      imageName:
        default: ${{ github.repository }}
        type: string
      imageTag:
        required: true
        type: string
      configureEnv:
        default: ''
        type: string
      useLocalArtifacts:
        default: false
        type: boolean

jobs:
  integration:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        # Divide integration tests into 3 shards, to run them in parallel.
        shardIndex: [1, 2, 3]

    env:
      DOCKER_REGISTRY:
        ${{ !inputs.useLocalArtifacts && format('{0}/{1}/', inputs.registry, inputs.imageName) || ''
        }}
      DOCKER_TAG: :${{ inputs.imageTag }}

    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: configure env vars
        if: ${{ inputs.configureEnv != '' }}
        run: ${{ inputs.configureEnv }}

      - name: setup environment
        uses: ./.github/actions/setup
        with:
          actor: test-integration
          cacheNext: false
          cacheTurbo: true

      - name: prepare packages
        run: pnpm --filter integration-tests prepare:env

      - name: patch compose file volumes
        uses: mikefarah/yq@v4.43.1
        with:
          cmd: yq -i 'del(.services.*.volumes)' docker/docker-compose.community.yml

      - name: get cpu count for vitest
        id: cpu-cores
        uses: SimenB/github-actions-cpu-cores@v2

      - name: download local artifact
        if: ${{ inputs.useLocalArtifacts }}
        uses: actions/download-artifact@v4
        with:
          name: docker_output
          path: docker_output

      - name: pull local images
        if: ${{ inputs.useLocalArtifacts }}
        working-directory: docker_output
        run: |
          for f in *.tar; do
            image_name=$(basename $f .tar)
            image_tag="${image_name}:${{ inputs.imageTag }}"
            echo "loading local docker image $f as tag $image_tag"

            cat $f | docker import - $image_tag
          done
          docker image ls -a
          rm -rf docker_output
          rm -rf /usr/share/dotnet/
          rm -rf /opt/hostedtoolcache
          df -h

      - name: run containers
        timeout-minutes: 10
        run: |
          docker compose -f docker/docker-compose.community.yml -f ./integration-tests/docker-compose.integration.yaml --env-file ./integration-tests/.env up -d --wait

      - name: troubleshoot containers
        if: ${{ failure() }}
        run: |
          docker compose -f docker/docker-compose.community.yml -f ./integration-tests/docker-compose.integration.yaml --env-file ./integration-tests/.env ps
          docker compose -f docker/docker-compose.community.yml -f ./integration-tests/docker-compose.integration.yaml --env-file ./integration-tests/.env logs

      - name: run integration tests
        timeout-minutes: 10
        env:
          HIVE_DEBUG: 1
        run: |
          VITEST_MAX_THREADS=${{ steps.cpu-cores.outputs.count }} pnpm --filter integration-tests test:integration --shard=${{ matrix.shardIndex }}/3

      - name: log dump
        if: ${{ failure() }}
        run: |
          docker compose -f docker/docker-compose.community.yml -f ./integration-tests/docker-compose.integration.yaml --env-file ./integration-tests/.env logs
